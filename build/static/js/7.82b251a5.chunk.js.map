{"version":3,"sources":["pages/settings/SettingsRoute.tsx","components/Button.tsx","util/roger-api-client.ts"],"names":["SettingsRoute","useState","working","setWorking","message","setMessage","reset","client","className","variant","onClick","disabled","Button","color","backgroundColor","children","ButtonStyled","styled","button","css","memo","ExpenseStatus","RogerApiClient","listeners","Map","expenseId","randomWait","storage","this","getExpensesStorage","Error","Object","values","sort","a","b","createdAt","localeCompare","file","expense","id","uuidv4","Date","toISOString","filename","name","status","ANALYZING","vendorName","amount","updateExpensesStorage","setTimeout","UNPAID","faker","company","companyName","commerce","price","emit","randomLatency","changes","assign","eventName","listener","eventListeners","get","Set","set","add","delete","args","forEach","raw","localStorage","getItem","JSON","parse","callback","setItem","stringify","min","max","Math","round","random","Promise","resolve","window"],"mappings":"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","file":"static/js/7.82b251a5.chunk.js","sourcesContent":["import React, {useState} from 'react'\nimport Button from '../../components/Button'\nimport {client} from '../../util/roger-api-client'\n\nexport const SettingsRoute: React.FC<{}> = () => {\n  const [working, setWorking] = useState(false)\n  const [message, setMessage] = useState('')\n\n  const reset = async () => {\n    setWorking(true)\n    await client.reset()\n    setWorking(false)\n    setMessage('All expenses were deleted.')\n  }\n  return (\n    <>\n      <h1>Data reset</h1>\n      <p>Clicking this button will delete all expenses from localStorage.</p>\n      {message && <div className=\"alert alert-info\">{message}</div>}\n      <p>\n        <Button variant=\"danger\" onClick={reset} disabled={working}>\n          Delete all expenses\n        </Button>\n      </p>\n    </>\n  )\n}\n\nexport default SettingsRoute\n","import React, {memo} from 'react'\nimport styled, {css} from 'styled-components/macro'\n\nexport type ButtonVariants = 'primary' | 'danger'\n\ntype ButtonProps = {\n  className?: string\n  children: React.ReactNode\n  disabled?: boolean\n  onClick: (evt?: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void\n  color?: string\n  backgroundColor?: string\n  variant?: ButtonVariants\n}\n\nconst Button: React.FC<ButtonProps> = ({\n  className,\n  onClick,\n  color,\n  backgroundColor,\n  children,\n  variant = 'primary',\n}) => {\n  return (\n    <ButtonStyled\n      className={className}\n      color={color}\n      backgroundColor={backgroundColor}\n      onClick={onClick}\n      variant={variant}\n    >\n      {children}\n    </ButtonStyled>\n  )\n}\n\nconst ButtonStyled = styled.button<{\n  color?: string\n  backgroundColor?: string\n  variant?: ButtonVariants\n}>`\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  border-radius: 4px;\n  border: none;\n  cursor: pointer;\n  padding: 5px 10px;\n  user-select: none;\n\n  color: ${({color}) => color || 'white'};\n  background-color: ${({backgroundColor}) => backgroundColor || '#371e88'};\n\n  ${({variant}) =>\n    variant === 'primary' &&\n    css`\n      background-color: #0071b1;\n      &:hover,\n      &:focus {\n        filter: brightness(112%);\n      }\n      &:active {\n        filter: brightness(124%);\n      }\n    `}\n\n  ${({variant}) =>\n    variant === 'danger' &&\n    css`\n      background-color: #d73814;\n      &:hover,\n      &:focus {\n        filter: brightness(112%);\n      }\n      &:active {\n        filter: brightness(124%);\n      }\n    `}\n`\n\nexport default memo(Button)\n","import uuidv4 from 'uuid/v4'\nimport faker from 'faker'\n\n/**\n * Shape of a expense.\n */\nexport interface Expense {\n  /**\n   * Automatically generated by the \"backend\".\n   */\n  id: string\n\n  /**\n   * ISO 8601\n   */\n  createdAt: string\n\n  /**\n   * Name of file that was uploaded for the expense.\n   */\n  filename: string\n\n  /**\n   * The expense's current status. See `ExpenseStatus` for a description of a expense's\n   * life cycle.\n   */\n  status: ExpenseStatus\n\n  /**\n   * When uploaded, this field will be `null`. When expense analysis completes, it\n   * will be populated with the vendor's name.\n   */\n  vendorName: string | null\n\n  /**\n   * When uploaded, this field will be `null`. When expense analysis completes, it\n   * will be populated with the amount due.\n   */\n  amount: string | null\n}\n\n/**\n * Newly uploaded expenses start out as being analyzed. After a period of time,\n * they become unpaid. When a user marks them as such, they become paid.\n */\nexport enum ExpenseStatus {\n  ANALYZING = 'ANALYZING',\n  UNPAID = 'UNPAID',\n  PAID = 'PAID'\n}\n\n/**\n * Fake implementation of a primitive API that handles expenses.\n */\nclass RogerApiClient {\n  private listeners = new Map<string, Set<Listener>>()\n\n  /**\n   * Finds a single expense by its ID and resolves with it. Will reject if the expense\n   * does not exist.\n   */\n  async getExpense(expenseId: string): Promise<Expense> {\n    await randomWait()\n    const storage = this.getExpensesStorage()\n    if (!storage[expenseId]) {\n      throw new Error(`Expense '${expenseId}' not found`)\n    }\n    return storage[expenseId]\n  }\n\n  /**\n   * Resolves with a list of all expenses sorted by `createdAt` in descending\n   * order.\n   */\n  async listExpenses(): Promise<Expense[]> {\n    await randomWait()\n    const storage = this.getExpensesStorage()\n    return Object.values(storage).sort((a, b) =>\n      b.createdAt.localeCompare(b.createdAt)\n    )\n  }\n\n  /**\n   * Takes a `File` object, which the user has selected for upload. Uploads the\n   * file (which takes a few seconds), and then resolves with a new `Expense`\n   * object with status=ANALYZING.\n   *\n   * After a random period of time, the expense will be analyzed and be marked as\n   * paid. Listen for `expenseAnalyzed` events through the `on` method.\n   */\n  async uploadExpense(file: File): Promise<Expense> {\n    await randomWait(2000, 4000)\n\n    // Insert expense\n    const expense: Expense = {\n      id: uuidv4(),\n      createdAt: new Date().toISOString(),\n      filename: file.name,\n      status: ExpenseStatus.ANALYZING,\n      vendorName: null,\n      amount: null\n    }\n    this.updateExpensesStorage(storage => {\n      storage[expense.id] = expense\n      return storage\n    })\n\n    // After a random timeout, we're done analyzing\n    setTimeout(() => {\n      this.updateExpensesStorage(storage => {\n        const b = storage[expense.id]\n        if (b) {\n          b.status = ExpenseStatus.UNPAID\n          b.vendorName = faker.company.companyName()\n          b.amount = faker.commerce.price()\n        }\n        return storage\n      })\n      const storage = this.getExpensesStorage()\n      this.emit('expenseAnalyzed', storage[expense.id])\n    }, randomLatency(3000, 8000))\n\n    // Return the expense\n    return expense\n  }\n\n  /**\n   * Updates a single expense. Only keys included in `changes` are changed - other\n   * keys are left intact. Resolves with updated `Expense` object. Rejects if expense\n   * does not exist.\n   */\n  async patchExpense(\n    expenseId: string,\n    changes: Partial<Expense>\n  ): Promise<Expense> {\n    await randomWait()\n    this.updateExpensesStorage(storage => {\n      if (!storage[expenseId]) {\n        throw new Error(`Expense '${expenseId}' not found`)\n      }\n      Object.assign(storage[expenseId], changes)\n      return storage\n    })\n    return this.getExpensesStorage()[expenseId]\n  }\n\n  /**\n   * Deletes a expense and resolves when successful. Idempotent.\n   */\n  async deleteExpense(expenseId: string): Promise<void> {\n    await randomWait()\n    this.updateExpensesStorage(storage => {\n      delete storage[expenseId]\n      return storage\n    })\n  }\n\n  /**\n   * Resets the database by deleting all expenses.\n   */\n  async reset(): Promise<void> {\n    this.updateExpensesStorage(() => ({}))\n  }\n\n  /**\n   * Register a listener for events from the \"back-end\". `listener` will be\n   * called when events of the given `eventName` are emitted. The following\n   * events are supported:\n   *\n   * - `expenseAnalyzed`: Called when analisis completes for a expense. Listener will\n   *   be called with the `Expense` object that was updated.\n   */\n  on(eventName: 'expenseAnalyzed', listener: (expense: Expense) => void): void\n  on(eventName: string, listener: Listener): void {\n    let eventListeners = this.listeners.get(eventName)\n    if (!eventListeners) {\n      eventListeners = new Set()\n      this.listeners.set(eventName, eventListeners)\n    }\n    eventListeners.add(listener)\n  }\n\n  /**\n   * Removes a listener previously registered with `on`.\n   */\n  off(eventName: string, listener: Listener) {\n    let eventListeners = this.listeners.get(eventName)\n    if (eventListeners) {\n      eventListeners.delete(listener)\n    }\n  }\n\n  private emit(eventName: 'expenseAnalyzed', expense: Expense): void\n  private emit(eventName: string, ...args: any[]): void {\n    let eventListeners = this.listeners.get(eventName)\n    if (eventListeners) {\n      eventListeners.forEach(listener => listener(...args))\n    }\n  }\n\n  private getExpensesStorage(): ExpensesStorage {\n    const raw = localStorage.getItem('roger-tht-expenses')\n    if (!raw) {\n      return {}\n    }\n    return JSON.parse(raw)\n  }\n\n  private updateExpensesStorage(\n    callback: (storage: ExpensesStorage) => ExpensesStorage\n  ) {\n    const storage = callback(this.getExpensesStorage())\n    localStorage.setItem('roger-tht-expenses', JSON.stringify(storage))\n  }\n}\n\nexport const client = new RogerApiClient()\n\n// Utility types and functions\ntype Listener = (...args: any[]) => void\n\ntype ExpensesStorage = {[id: string]: Expense}\n\nfunction randomLatency(min: number = 200, max: number = 500) {\n  return process.env.NODE_ENV === 'test'\n    ? 1\n    : Math.round(min + Math.random() * max)\n}\n\nasync function randomWait(min: number = 200, max: number = 500) {\n  await new Promise(resolve =>\n    window.setTimeout(resolve, randomLatency(min, max))\n  )\n}\n"],"sourceRoot":""}