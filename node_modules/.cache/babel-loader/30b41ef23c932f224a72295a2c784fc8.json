{"ast":null,"code":"import uuidv4 from 'uuid/v4';\nimport faker from 'faker';\n/**\n * Shape of a expense.\n */\n\n/**\n * Newly uploaded expenses start out as being analyzed. After a period of time,\n * they become unpaid. When a user marks them as such, they become paid.\n */\nexport let ExpenseStatus;\n/**\n * Fake implementation of a primitive API that handles expenses.\n */\n\n(function (ExpenseStatus) {\n  ExpenseStatus[\"ANALYZING\"] = \"ANALYZING\";\n  ExpenseStatus[\"UNPAID\"] = \"UNPAID\";\n  ExpenseStatus[\"PAID\"] = \"PAID\";\n})(ExpenseStatus || (ExpenseStatus = {}));\n\nclass RogerApiClient {\n  constructor() {\n    this.listeners = new Map();\n  }\n\n  /**\n   * Finds a single expense by its ID and resolves with it. Will reject if the expense\n   * does not exist.\n   */\n  async getExpense(expenseId) {\n    await randomWait();\n    const storage = this.getExpensesStorage();\n\n    if (!storage[expenseId]) {\n      throw new Error(`Expense '${expenseId}' not found`);\n    }\n\n    return storage[expenseId];\n  }\n  /**\n   * Resolves with a list of all expenses sorted by `createdAt` in descending\n   * order.\n   */\n\n\n  async listExpenses() {\n    await randomWait();\n    const storage = this.getExpensesStorage();\n    return Object.values(storage).sort((a, b) => b.createdAt.localeCompare(b.createdAt));\n  }\n  /**\n   * Takes a `File` object, which the user has selected for upload. Uploads the\n   * file (which takes a few seconds), and then resolves with a new `Expense`\n   * object with status=ANALYZING.\n   *\n   * After a random period of time, the expense will be analyzed and be marked as\n   * paid. Listen for `expenseAnalyzed` events through the `on` method.\n   */\n\n\n  async uploadExpense(file) {\n    await randomWait(2000, 4000); // Insert expense\n\n    const expense = {\n      id: uuidv4(),\n      createdAt: new Date().toISOString(),\n      filename: file.name,\n      status: ExpenseStatus.ANALYZING,\n      vendorName: null,\n      amount: null\n    };\n    this.updateExpensesStorage(storage => {\n      storage[expense.id] = expense;\n      return storage;\n    }); // After a random timeout, we're done analyzing\n\n    setTimeout(() => {\n      this.updateExpensesStorage(storage => {\n        const b = storage[expense.id];\n\n        if (b) {\n          b.status = ExpenseStatus.UNPAID;\n          b.vendorName = faker.company.companyName();\n          b.amount = faker.commerce.price();\n        }\n\n        return storage;\n      });\n      const storage = this.getExpensesStorage();\n      this.emit('expenseAnalyzed', storage[expense.id]);\n    }, randomLatency(3000, 8000)); // Return the expense\n\n    return expense;\n  }\n  /**\n   * Updates a single expense. Only keys included in `changes` are changed - other\n   * keys are left intact. Resolves with updated `Expense` object. Rejects if expense\n   * does not exist.\n   */\n\n\n  async patchExpense(expenseId, changes) {\n    await randomWait();\n    this.updateExpensesStorage(storage => {\n      if (!storage[expenseId]) {\n        throw new Error(`Expense '${expenseId}' not found`);\n      }\n\n      Object.assign(storage[expenseId], changes);\n      return storage;\n    });\n    return this.getExpensesStorage()[expenseId];\n  }\n  /**\n   * Deletes a expense and resolves when successful. Idempotent.\n   */\n\n\n  async deleteExpense(expenseId) {\n    await randomWait();\n    this.updateExpensesStorage(storage => {\n      delete storage[expenseId];\n      return storage;\n    });\n  }\n  /**\n   * Resets the database by deleting all expenses.\n   */\n\n\n  async reset() {\n    this.updateExpensesStorage(() => ({}));\n  }\n  /**\n   * Register a listener for events from the \"back-end\". `listener` will be\n   * called when events of the given `eventName` are emitted. The following\n   * events are supported:\n   *\n   * - `expenseAnalyzed`: Called when analisis completes for a expense. Listener will\n   *   be called with the `Expense` object that was updated.\n   */\n\n\n  on(eventName, listener) {\n    let eventListeners = this.listeners.get(eventName);\n\n    if (!eventListeners) {\n      eventListeners = new Set();\n      this.listeners.set(eventName, eventListeners);\n    }\n\n    eventListeners.add(listener);\n  }\n  /**\n   * Removes a listener previously registered with `on`.\n   */\n\n\n  off(eventName, listener) {\n    let eventListeners = this.listeners.get(eventName);\n\n    if (eventListeners) {\n      eventListeners.delete(listener);\n    }\n  }\n\n  emit(eventName) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    let eventListeners = this.listeners.get(eventName);\n\n    if (eventListeners) {\n      eventListeners.forEach(listener => listener(...args));\n    }\n  }\n\n  getExpensesStorage() {\n    const raw = localStorage.getItem('roger-tht-expenses');\n\n    if (!raw) {\n      return {};\n    }\n\n    return JSON.parse(raw);\n  }\n\n  updateExpensesStorage(callback) {\n    const storage = callback(this.getExpensesStorage());\n    localStorage.setItem('roger-tht-expenses', JSON.stringify(storage));\n  }\n\n}\n\nexport const client = new RogerApiClient(); // Utility types and functions\n\nfunction randomLatency() {\n  let min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 200;\n  let max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;\n  return process.env.NODE_ENV === 'test' ? 1 : Math.round(min + Math.random() * max);\n}\n\nasync function randomWait() {\n  let min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 200;\n  let max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;\n  await new Promise(resolve => window.setTimeout(resolve, randomLatency(min, max)));\n}","map":{"version":3,"names":["uuidv4","faker","ExpenseStatus","RogerApiClient","listeners","Map","getExpense","expenseId","randomWait","storage","getExpensesStorage","Error","listExpenses","Object","values","sort","a","b","createdAt","localeCompare","uploadExpense","file","expense","id","Date","toISOString","filename","name","status","ANALYZING","vendorName","amount","updateExpensesStorage","setTimeout","UNPAID","company","companyName","commerce","price","emit","randomLatency","patchExpense","changes","assign","deleteExpense","reset","on","eventName","listener","eventListeners","get","Set","set","add","off","delete","args","forEach","raw","localStorage","getItem","JSON","parse","callback","setItem","stringify","client","min","max","process","env","NODE_ENV","Math","round","random","Promise","resolve","window"],"sources":["/Users/macbook/Desktop/corpayone-michael-two/src/util/roger-api-client.ts"],"sourcesContent":["import uuidv4 from 'uuid/v4'\nimport faker from 'faker'\n\n/**\n * Shape of a expense.\n */\nexport interface Expense {\n  /**\n   * Automatically generated by the \"backend\".\n   */\n  id: string\n\n  /**\n   * ISO 8601\n   */\n  createdAt: string\n\n  /**\n   * Name of file that was uploaded for the expense.\n   */\n  filename: string\n\n  /**\n   * The expense's current status. See `ExpenseStatus` for a description of a expense's\n   * life cycle.\n   */\n  status: ExpenseStatus\n\n  /**\n   * When uploaded, this field will be `null`. When expense analysis completes, it\n   * will be populated with the vendor's name.\n   */\n  vendorName: string | null\n\n  /**\n   * When uploaded, this field will be `null`. When expense analysis completes, it\n   * will be populated with the amount due.\n   */\n  amount: string | null\n}\n\n/**\n * Newly uploaded expenses start out as being analyzed. After a period of time,\n * they become unpaid. When a user marks them as such, they become paid.\n */\nexport enum ExpenseStatus {\n  ANALYZING = 'ANALYZING',\n  UNPAID = 'UNPAID',\n  PAID = 'PAID'\n}\n\n/**\n * Fake implementation of a primitive API that handles expenses.\n */\nclass RogerApiClient {\n  private listeners = new Map<string, Set<Listener>>()\n\n  /**\n   * Finds a single expense by its ID and resolves with it. Will reject if the expense\n   * does not exist.\n   */\n  async getExpense(expenseId: string): Promise<Expense> {\n    await randomWait()\n    const storage = this.getExpensesStorage()\n    if (!storage[expenseId]) {\n      throw new Error(`Expense '${expenseId}' not found`)\n    }\n    return storage[expenseId]\n  }\n\n  /**\n   * Resolves with a list of all expenses sorted by `createdAt` in descending\n   * order.\n   */\n  async listExpenses(): Promise<Expense[]> {\n    await randomWait()\n    const storage = this.getExpensesStorage()\n    return Object.values(storage).sort((a, b) =>\n      b.createdAt.localeCompare(b.createdAt)\n    )\n  }\n\n  /**\n   * Takes a `File` object, which the user has selected for upload. Uploads the\n   * file (which takes a few seconds), and then resolves with a new `Expense`\n   * object with status=ANALYZING.\n   *\n   * After a random period of time, the expense will be analyzed and be marked as\n   * paid. Listen for `expenseAnalyzed` events through the `on` method.\n   */\n  async uploadExpense(file: File): Promise<Expense> {\n    await randomWait(2000, 4000)\n\n    // Insert expense\n    const expense: Expense = {\n      id: uuidv4(),\n      createdAt: new Date().toISOString(),\n      filename: file.name,\n      status: ExpenseStatus.ANALYZING,\n      vendorName: null,\n      amount: null\n    }\n    this.updateExpensesStorage(storage => {\n      storage[expense.id] = expense\n      return storage\n    })\n\n    // After a random timeout, we're done analyzing\n    setTimeout(() => {\n      this.updateExpensesStorage(storage => {\n        const b = storage[expense.id]\n        if (b) {\n          b.status = ExpenseStatus.UNPAID\n          b.vendorName = faker.company.companyName()\n          b.amount = faker.commerce.price()\n        }\n        return storage\n      })\n      const storage = this.getExpensesStorage()\n      this.emit('expenseAnalyzed', storage[expense.id])\n    }, randomLatency(3000, 8000))\n\n    // Return the expense\n    return expense\n  }\n\n  /**\n   * Updates a single expense. Only keys included in `changes` are changed - other\n   * keys are left intact. Resolves with updated `Expense` object. Rejects if expense\n   * does not exist.\n   */\n  async patchExpense(\n    expenseId: string,\n    changes: Partial<Expense>\n  ): Promise<Expense> {\n    await randomWait()\n    this.updateExpensesStorage(storage => {\n      if (!storage[expenseId]) {\n        throw new Error(`Expense '${expenseId}' not found`)\n      }\n      Object.assign(storage[expenseId], changes)\n      return storage\n    })\n    return this.getExpensesStorage()[expenseId]\n  }\n\n  /**\n   * Deletes a expense and resolves when successful. Idempotent.\n   */\n  async deleteExpense(expenseId: string): Promise<void> {\n    await randomWait()\n    this.updateExpensesStorage(storage => {\n      delete storage[expenseId]\n      return storage\n    })\n  }\n\n  /**\n   * Resets the database by deleting all expenses.\n   */\n  async reset(): Promise<void> {\n    this.updateExpensesStorage(() => ({}))\n  }\n\n  /**\n   * Register a listener for events from the \"back-end\". `listener` will be\n   * called when events of the given `eventName` are emitted. The following\n   * events are supported:\n   *\n   * - `expenseAnalyzed`: Called when analisis completes for a expense. Listener will\n   *   be called with the `Expense` object that was updated.\n   */\n  on(eventName: 'expenseAnalyzed', listener: (expense: Expense) => void): void\n  on(eventName: string, listener: Listener): void {\n    let eventListeners = this.listeners.get(eventName)\n    if (!eventListeners) {\n      eventListeners = new Set()\n      this.listeners.set(eventName, eventListeners)\n    }\n    eventListeners.add(listener)\n  }\n\n  /**\n   * Removes a listener previously registered with `on`.\n   */\n  off(eventName: string, listener: Listener) {\n    let eventListeners = this.listeners.get(eventName)\n    if (eventListeners) {\n      eventListeners.delete(listener)\n    }\n  }\n\n  private emit(eventName: 'expenseAnalyzed', expense: Expense): void\n  private emit(eventName: string, ...args: any[]): void {\n    let eventListeners = this.listeners.get(eventName)\n    if (eventListeners) {\n      eventListeners.forEach(listener => listener(...args))\n    }\n  }\n\n  private getExpensesStorage(): ExpensesStorage {\n    const raw = localStorage.getItem('roger-tht-expenses')\n    if (!raw) {\n      return {}\n    }\n    return JSON.parse(raw)\n  }\n\n  private updateExpensesStorage(\n    callback: (storage: ExpensesStorage) => ExpensesStorage\n  ) {\n    const storage = callback(this.getExpensesStorage())\n    localStorage.setItem('roger-tht-expenses', JSON.stringify(storage))\n  }\n}\n\nexport const client = new RogerApiClient()\n\n// Utility types and functions\ntype Listener = (...args: any[]) => void\n\ntype ExpensesStorage = {[id: string]: Expense}\n\nfunction randomLatency(min: number = 200, max: number = 500) {\n  return process.env.NODE_ENV === 'test'\n    ? 1\n    : Math.round(min + Math.random() * max)\n}\n\nasync function randomWait(min: number = 200, max: number = 500) {\n  await new Promise(resolve =>\n    window.setTimeout(resolve, randomLatency(min, max))\n  )\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}