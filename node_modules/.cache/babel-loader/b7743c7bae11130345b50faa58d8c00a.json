{"ast":null,"code":"import _regeneratorRuntime from\"/Users/macbook/Desktop/corpayone-michael-two/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";import _asyncToGenerator from\"/Users/macbook/Desktop/corpayone-michael-two/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";import _classCallCheck from\"/Users/macbook/Desktop/corpayone-michael-two/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";import _createClass from\"/Users/macbook/Desktop/corpayone-michael-two/node_modules/@babel/runtime/helpers/esm/createClass.js\";import uuidv4 from'uuid/v4';import faker from'faker';/**\n * Shape of a expense.\n */ /**\n * Newly uploaded expenses start out as being analyzed. After a period of time,\n * they become unpaid. When a user marks them as such, they become paid.\n */export var ExpenseStatus;/**\n * Fake implementation of a primitive API that handles expenses.\n */(function(ExpenseStatus){ExpenseStatus[\"ANALYZING\"]=\"ANALYZING\";ExpenseStatus[\"UNPAID\"]=\"UNPAID\";ExpenseStatus[\"PAID\"]=\"PAID\";})(ExpenseStatus||(ExpenseStatus={}));var RogerApiClient=/*#__PURE__*/function(){function RogerApiClient(){_classCallCheck(this,RogerApiClient);this.listeners=new Map();}_createClass(RogerApiClient,[{key:\"getExpense\",value:/**\n   * Finds a single expense by its ID and resolves with it. Will reject if the expense\n   * does not exist.\n   */function(){var _getExpense=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(expenseId){var storage;return _regeneratorRuntime().wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return randomWait();case 2:storage=this.getExpensesStorage();if(storage[expenseId]){_context.next=5;break;}throw new Error(\"Expense '\".concat(expenseId,\"' not found\"));case 5:return _context.abrupt(\"return\",storage[expenseId]);case 6:case\"end\":return _context.stop();}}},_callee,this);}));function getExpense(_x){return _getExpense.apply(this,arguments);}return getExpense;}()/**\n   * Resolves with a list of all expenses sorted by `createdAt` in descending\n   * order.\n   */},{key:\"listExpenses\",value:function(){var _listExpenses=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(){var storage;return _regeneratorRuntime().wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:_context2.next=2;return randomWait();case 2:storage=this.getExpensesStorage();return _context2.abrupt(\"return\",Object.values(storage).sort(function(a,b){return b.createdAt.localeCompare(b.createdAt);}));case 4:case\"end\":return _context2.stop();}}},_callee2,this);}));function listExpenses(){return _listExpenses.apply(this,arguments);}return listExpenses;}()/**\n   * Takes a `File` object, which the user has selected for upload. Uploads the\n   * file (which takes a few seconds), and then resolves with a new `Expense`\n   * object with status=ANALYZING.\n   *\n   * After a random period of time, the expense will be analyzed and be marked as\n   * paid. Listen for `expenseAnalyzed` events through the `on` method.\n   */},{key:\"uploadExpense\",value:function(){var _uploadExpense=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(file){var _this=this;var expense;return _regeneratorRuntime().wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:_context3.next=2;return randomWait(2000,4000);case 2:// Insert expense\nexpense={id:uuidv4(),createdAt:new Date().toISOString(),filename:file.name,status:ExpenseStatus.ANALYZING,vendorName:null,amount:null};this.updateExpensesStorage(function(storage){storage[expense.id]=expense;return storage;});// After a random timeout, we're done analyzing\nsetTimeout(function(){_this.updateExpensesStorage(function(storage){var b=storage[expense.id];if(b){b.status=ExpenseStatus.UNPAID;b.vendorName=faker.company.companyName();b.amount=faker.commerce.price();}return storage;});var storage=_this.getExpensesStorage();_this.emit('expenseAnalyzed',storage[expense.id]);},randomLatency(3000,8000));// Return the expense\nreturn _context3.abrupt(\"return\",expense);case 6:case\"end\":return _context3.stop();}}},_callee3,this);}));function uploadExpense(_x2){return _uploadExpense.apply(this,arguments);}return uploadExpense;}()/**\n   * Updates a single expense. Only keys included in `changes` are changed - other\n   * keys are left intact. Resolves with updated `Expense` object. Rejects if expense\n   * does not exist.\n   */},{key:\"patchExpense\",value:function(){var _patchExpense=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(expenseId,changes){return _regeneratorRuntime().wrap(function _callee4$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:_context4.next=2;return randomWait();case 2:this.updateExpensesStorage(function(storage){if(!storage[expenseId]){throw new Error(\"Expense '\".concat(expenseId,\"' not found\"));}Object.assign(storage[expenseId],changes);return storage;});return _context4.abrupt(\"return\",this.getExpensesStorage()[expenseId]);case 4:case\"end\":return _context4.stop();}}},_callee4,this);}));function patchExpense(_x3,_x4){return _patchExpense.apply(this,arguments);}return patchExpense;}()/**\n   * Deletes a expense and resolves when successful. Idempotent.\n   */},{key:\"deleteExpense\",value:function(){var _deleteExpense=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(expenseId){return _regeneratorRuntime().wrap(function _callee5$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:_context5.next=2;return randomWait();case 2:this.updateExpensesStorage(function(storage){delete storage[expenseId];return storage;});case 3:case\"end\":return _context5.stop();}}},_callee5,this);}));function deleteExpense(_x5){return _deleteExpense.apply(this,arguments);}return deleteExpense;}()/**\n   * Resets the database by deleting all expenses.\n   */},{key:\"reset\",value:function(){var _reset=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(){return _regeneratorRuntime().wrap(function _callee6$(_context6){while(1){switch(_context6.prev=_context6.next){case 0:this.updateExpensesStorage(function(){return{};});case 1:case\"end\":return _context6.stop();}}},_callee6,this);}));function reset(){return _reset.apply(this,arguments);}return reset;}()/**\n   * Register a listener for events from the \"back-end\". `listener` will be\n   * called when events of the given `eventName` are emitted. The following\n   * events are supported:\n   *\n   * - `expenseAnalyzed`: Called when analisis completes for a expense. Listener will\n   *   be called with the `Expense` object that was updated.\n   */},{key:\"on\",value:function on(eventName,listener){var eventListeners=this.listeners.get(eventName);if(!eventListeners){eventListeners=new Set();this.listeners.set(eventName,eventListeners);}eventListeners.add(listener);}/**\n   * Removes a listener previously registered with `on`.\n   */},{key:\"off\",value:function off(eventName,listener){var eventListeners=this.listeners.get(eventName);if(eventListeners){eventListeners.delete(listener);}}},{key:\"emit\",value:function emit(eventName){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}var eventListeners=this.listeners.get(eventName);if(eventListeners){eventListeners.forEach(function(listener){return listener.apply(void 0,args);});}}},{key:\"getExpensesStorage\",value:function getExpensesStorage(){var raw=localStorage.getItem('roger-tht-expenses');if(!raw){return{};}return JSON.parse(raw);}},{key:\"updateExpensesStorage\",value:function updateExpensesStorage(callback){var storage=callback(this.getExpensesStorage());localStorage.setItem('roger-tht-expenses',JSON.stringify(storage));}}]);return RogerApiClient;}();export var client=new RogerApiClient();// Utility types and functions\nfunction randomLatency(){var min=arguments.length>0&&arguments[0]!==undefined?arguments[0]:200;var max=arguments.length>1&&arguments[1]!==undefined?arguments[1]:500;return process.env.NODE_ENV==='test'?1:Math.round(min+Math.random()*max);}function randomWait(){return _randomWait.apply(this,arguments);}function _randomWait(){_randomWait=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(){var min,max,_args7=arguments;return _regeneratorRuntime().wrap(function _callee7$(_context7){while(1){switch(_context7.prev=_context7.next){case 0:min=_args7.length>0&&_args7[0]!==undefined?_args7[0]:200;max=_args7.length>1&&_args7[1]!==undefined?_args7[1]:500;_context7.next=4;return new Promise(function(resolve){return window.setTimeout(resolve,randomLatency(min,max));});case 4:case\"end\":return _context7.stop();}}},_callee7);}));return _randomWait.apply(this,arguments);}","map":{"version":3,"names":["uuidv4","faker","ExpenseStatus","RogerApiClient","listeners","Map","expenseId","randomWait","storage","getExpensesStorage","Error","Object","values","sort","a","b","createdAt","localeCompare","file","expense","id","Date","toISOString","filename","name","status","ANALYZING","vendorName","amount","updateExpensesStorage","setTimeout","UNPAID","company","companyName","commerce","price","emit","randomLatency","changes","assign","eventName","listener","eventListeners","get","Set","set","add","delete","args","forEach","raw","localStorage","getItem","JSON","parse","callback","setItem","stringify","client","min","max","process","env","NODE_ENV","Math","round","random","Promise","resolve","window"],"sources":["/Users/macbook/Desktop/corpayone-michael-two/src/util/roger-api-client.ts"],"sourcesContent":["import uuidv4 from 'uuid/v4'\nimport faker from 'faker'\n\n/**\n * Shape of a expense.\n */\nexport interface Expense {\n  /**\n   * Automatically generated by the \"backend\".\n   */\n  id: string\n\n  /**\n   * ISO 8601\n   */\n  createdAt: string\n\n  /**\n   * Name of file that was uploaded for the expense.\n   */\n  filename: string\n\n  /**\n   * The expense's current status. See `ExpenseStatus` for a description of a expense's\n   * life cycle.\n   */\n  status: ExpenseStatus\n\n  /**\n   * When uploaded, this field will be `null`. When expense analysis completes, it\n   * will be populated with the vendor's name.\n   */\n  vendorName: string | null\n\n  /**\n   * When uploaded, this field will be `null`. When expense analysis completes, it\n   * will be populated with the amount due.\n   */\n  amount: string | null\n}\n\n/**\n * Newly uploaded expenses start out as being analyzed. After a period of time,\n * they become unpaid. When a user marks them as such, they become paid.\n */\nexport enum ExpenseStatus {\n  ANALYZING = 'ANALYZING',\n  UNPAID = 'UNPAID',\n  PAID = 'PAID'\n}\n\n/**\n * Fake implementation of a primitive API that handles expenses.\n */\nclass RogerApiClient {\n  private listeners = new Map<string, Set<Listener>>()\n\n  /**\n   * Finds a single expense by its ID and resolves with it. Will reject if the expense\n   * does not exist.\n   */\n  async getExpense(expenseId: string): Promise<Expense> {\n    await randomWait()\n    const storage = this.getExpensesStorage()\n    if (!storage[expenseId]) {\n      throw new Error(`Expense '${expenseId}' not found`)\n    }\n    return storage[expenseId]\n  }\n\n  /**\n   * Resolves with a list of all expenses sorted by `createdAt` in descending\n   * order.\n   */\n  async listExpenses(): Promise<Expense[]> {\n    await randomWait()\n    const storage = this.getExpensesStorage()\n    return Object.values(storage).sort((a, b) =>\n      b.createdAt.localeCompare(b.createdAt)\n    )\n  }\n\n  /**\n   * Takes a `File` object, which the user has selected for upload. Uploads the\n   * file (which takes a few seconds), and then resolves with a new `Expense`\n   * object with status=ANALYZING.\n   *\n   * After a random period of time, the expense will be analyzed and be marked as\n   * paid. Listen for `expenseAnalyzed` events through the `on` method.\n   */\n  async uploadExpense(file: File): Promise<Expense> {\n    await randomWait(2000, 4000)\n\n    // Insert expense\n    const expense: Expense = {\n      id: uuidv4(),\n      createdAt: new Date().toISOString(),\n      filename: file.name,\n      status: ExpenseStatus.ANALYZING,\n      vendorName: null,\n      amount: null\n    }\n    this.updateExpensesStorage(storage => {\n      storage[expense.id] = expense\n      return storage\n    })\n\n    // After a random timeout, we're done analyzing\n    setTimeout(() => {\n      this.updateExpensesStorage(storage => {\n        const b = storage[expense.id]\n        if (b) {\n          b.status = ExpenseStatus.UNPAID\n          b.vendorName = faker.company.companyName()\n          b.amount = faker.commerce.price()\n        }\n        return storage\n      })\n      const storage = this.getExpensesStorage()\n      this.emit('expenseAnalyzed', storage[expense.id])\n    }, randomLatency(3000, 8000))\n\n    // Return the expense\n    return expense\n  }\n\n  /**\n   * Updates a single expense. Only keys included in `changes` are changed - other\n   * keys are left intact. Resolves with updated `Expense` object. Rejects if expense\n   * does not exist.\n   */\n  async patchExpense(\n    expenseId: string,\n    changes: Partial<Expense>\n  ): Promise<Expense> {\n    await randomWait()\n    this.updateExpensesStorage(storage => {\n      if (!storage[expenseId]) {\n        throw new Error(`Expense '${expenseId}' not found`)\n      }\n      Object.assign(storage[expenseId], changes)\n      return storage\n    })\n    return this.getExpensesStorage()[expenseId]\n  }\n\n  /**\n   * Deletes a expense and resolves when successful. Idempotent.\n   */\n  async deleteExpense(expenseId: string): Promise<void> {\n    await randomWait()\n    this.updateExpensesStorage(storage => {\n      delete storage[expenseId]\n      return storage\n    })\n  }\n\n  /**\n   * Resets the database by deleting all expenses.\n   */\n  async reset(): Promise<void> {\n    this.updateExpensesStorage(() => ({}))\n  }\n\n  /**\n   * Register a listener for events from the \"back-end\". `listener` will be\n   * called when events of the given `eventName` are emitted. The following\n   * events are supported:\n   *\n   * - `expenseAnalyzed`: Called when analisis completes for a expense. Listener will\n   *   be called with the `Expense` object that was updated.\n   */\n  on(eventName: 'expenseAnalyzed', listener: (expense: Expense) => void): void\n  on(eventName: string, listener: Listener): void {\n    let eventListeners = this.listeners.get(eventName)\n    if (!eventListeners) {\n      eventListeners = new Set()\n      this.listeners.set(eventName, eventListeners)\n    }\n    eventListeners.add(listener)\n  }\n\n  /**\n   * Removes a listener previously registered with `on`.\n   */\n  off(eventName: string, listener: Listener) {\n    let eventListeners = this.listeners.get(eventName)\n    if (eventListeners) {\n      eventListeners.delete(listener)\n    }\n  }\n\n  private emit(eventName: 'expenseAnalyzed', expense: Expense): void\n  private emit(eventName: string, ...args: any[]): void {\n    let eventListeners = this.listeners.get(eventName)\n    if (eventListeners) {\n      eventListeners.forEach(listener => listener(...args))\n    }\n  }\n\n  private getExpensesStorage(): ExpensesStorage {\n    const raw = localStorage.getItem('roger-tht-expenses')\n    if (!raw) {\n      return {}\n    }\n    return JSON.parse(raw)\n  }\n\n  private updateExpensesStorage(\n    callback: (storage: ExpensesStorage) => ExpensesStorage\n  ) {\n    const storage = callback(this.getExpensesStorage())\n    localStorage.setItem('roger-tht-expenses', JSON.stringify(storage))\n  }\n}\n\nexport const client = new RogerApiClient()\n\n// Utility types and functions\ntype Listener = (...args: any[]) => void\n\ntype ExpensesStorage = {[id: string]: Expense}\n\nfunction randomLatency(min: number = 200, max: number = 500) {\n  return process.env.NODE_ENV === 'test'\n    ? 1\n    : Math.round(min + Math.random() * max)\n}\n\nasync function randomWait(min: number = 200, max: number = 500) {\n  await new Promise(resolve =>\n    window.setTimeout(resolve, randomLatency(min, max))\n  )\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}